header files pached for introspection workaround
makefile and other extra io-[format] sources are awfully merged from third party developers/library
note: there is thumbnailing issue when using libtiff so it's avoided otherwise libjpeg is waaay faster than gdiplus

--- gdk-pixbuf/gdk-pixbuf-animation.h	Thu Mar 06 11:36:45 2014
+++ gdk-pixbuf/gdk-pixbuf-animation.h	Wed May 28 10:48:29 2014
@@ -62,12 +62,6 @@
 
 GType               gdk_pixbuf_animation_get_type        (void) G_GNUC_CONST;
 
-#ifndef __GTK_DOC_IGNORE__
-#ifdef G_OS_WIN32
-#define gdk_pixbuf_animation_new_from_file gdk_pixbuf_animation_new_from_file_utf8
-#endif
-#endif
-
 GdkPixbufAnimation *gdk_pixbuf_animation_new_from_file   (const char         *filename,
                                                           GError            **error);
 GdkPixbufAnimation *gdk_pixbuf_animation_new_from_stream (GInputStream       *stream,
@@ -81,6 +75,16 @@
                                                           GError            **error);
 GdkPixbufAnimation *gdk_pixbuf_animation_new_from_resource(const char        *resource_path,
                                                           GError            **error);
+
+#ifndef __GTK_DOC_IGNORE__
+#ifdef G_OS_WIN32
+#define gdk_pixbuf_animation_new_from_file gdk_pixbuf_animation_new_from_file_utf8
+
+GdkPixbufAnimation *gdk_pixbuf_animation_new_from_file_utf8   (const char         *filename,
+                                                          GError            **error);
+
+#endif
+#endif
 
 #ifndef GDK_PIXBUF_DISABLE_DEPRECATED
 G_DEPRECATED_FOR(g_object_ref)
--- gdk-pixbuf/gdk-pixbuf-core.h	Sat Mar 15 04:09:46 2014
+++ gdk-pixbuf/gdk-pixbuf-core.h	Wed May 28 10:48:29 2014
@@ -261,15 +261,6 @@
 
 /* Simple loading */
 
-#ifndef __GTK_DOC_IGNORE__
-#ifdef G_OS_WIN32
-/* DLL ABI stability hack. */
-#define gdk_pixbuf_new_from_file gdk_pixbuf_new_from_file_utf8
-#define gdk_pixbuf_new_from_file_at_size gdk_pixbuf_new_from_file_at_size_utf8
-#define gdk_pixbuf_new_from_file_at_scale gdk_pixbuf_new_from_file_at_scale_utf8
-#endif
-#endif
-
 GdkPixbuf *gdk_pixbuf_new_from_file (const char *filename,
                                      GError    **error);
 GdkPixbuf *gdk_pixbuf_new_from_file_at_size (const char *filename,
@@ -303,33 +294,69 @@
 					 const guint8 *data,
 					 gboolean      copy_pixels,
 					 GError      **error);
-       
+
+#ifndef __GTK_DOC_IGNORE__
+#ifdef G_OS_WIN32
+/* DLL ABI stability hack. */
+#define gdk_pixbuf_new_from_file gdk_pixbuf_new_from_file_utf8
+#define gdk_pixbuf_new_from_file_at_size gdk_pixbuf_new_from_file_at_size_utf8
+#define gdk_pixbuf_new_from_file_at_scale gdk_pixbuf_new_from_file_at_scale_utf8
+
+GdkPixbuf *gdk_pixbuf_new_from_file_utf8 (const char *filename,
+                                     GError    **error);
+GdkPixbuf *gdk_pixbuf_new_from_file_at_size_utf8 (const char *filename,
+					     int         width, 
+					     int         height,
+					     GError    **error);
+GdkPixbuf *gdk_pixbuf_new_from_file_at_scale_utf8 (const char *filename,
+					      int         width, 
+					      int         height,
+					      gboolean    preserve_aspect_ratio,
+					      GError    **error);
+
+#endif
+#endif
+
 /* Mutations */
 void       gdk_pixbuf_fill              (GdkPixbuf    *pixbuf,
                                          guint32       pixel);
 
 /* Saving */
 
+gboolean gdk_pixbuf_save           (GdkPixbuf  *pixbuf, 
+                                    const char *filename, 
+                                    const char *type, 
+                                    GError    **error,
+                                    ...) G_GNUC_NULL_TERMINATED;
+
+gboolean gdk_pixbuf_savev          (GdkPixbuf  *pixbuf, 
+                                    const char *filename, 
+                                    const char *type,
+                                    char      **option_keys,
+                                    char      **option_values,
+                                    GError    **error);
+
 #ifndef __GTK_DOC_IGNORE__
 #ifdef G_OS_WIN32
 /* DLL ABI stability hack. */
 #define gdk_pixbuf_save gdk_pixbuf_save_utf8
 #define gdk_pixbuf_savev gdk_pixbuf_savev_utf8
-#endif
-#endif
 
-gboolean gdk_pixbuf_save           (GdkPixbuf  *pixbuf, 
+gboolean gdk_pixbuf_save_utf8           (GdkPixbuf  *pixbuf, 
                                     const char *filename, 
                                     const char *type, 
                                     GError    **error,
                                     ...) G_GNUC_NULL_TERMINATED;
 
-gboolean gdk_pixbuf_savev          (GdkPixbuf  *pixbuf, 
+gboolean gdk_pixbuf_savev_utf8          (GdkPixbuf  *pixbuf, 
                                     const char *filename, 
                                     const char *type,
                                     char      **option_keys,
                                     char      **option_values,
                                     GError    **error);
+
+#endif
+#endif
 
 /* Saving to a callback function */
 
--- gdk-pixbuf/gdk-pixbuf-io.c	Tue May 27 07:32:33 2014
+++ gdk-pixbuf/gdk-pixbuf-io.c	Wed May 28 10:48:40 2014
@@ -193,7 +193,9 @@
 
 /* DllMain function needed to tuck away the gdk-pixbuf DLL handle */
 
-static HMODULE gdk_pixbuf_dll;
+static HMODULE gdk_pixbuf_dll = NULL;
+
+#ifdef DLL_EXPORT
 
 BOOL WINAPI
 DllMain (HINSTANCE hinstDLL,
@@ -209,6 +211,8 @@
   return TRUE;
 }
 
+#endif
+
 char *
 _gdk_pixbuf_win32_get_toplevel (void)
 {
@@ -447,6 +451,18 @@
 #ifdef INCLUDE_jasper
         load_one_builtin_module (jasper);
 #endif
+#ifdef INCLUDE_svg
+        load_one_builtin_module (svg);
+#endif
+#ifdef INCLUDE_webp
+        load_one_builtin_module (webp);
+#endif
+#ifdef INCLUDE_psd
+        load_one_builtin_module (psd);
+#endif
+#ifdef INCLUDE_openraw
+        load_one_builtin_module (openraw);
+#endif
 #ifdef INCLUDE_qtif
         load_one_builtin_module (qtif);
 #endif
@@ -459,9 +475,13 @@
         load_one_builtin_module (emf);
         load_one_builtin_module (bmp);
         load_one_builtin_module (gif);
+#ifndef INCLUDE_jpeg
         load_one_builtin_module (jpeg);
+#endif
+#ifndef INCLUDE_tiff
         load_one_builtin_module (tiff);
 #endif
+#endif
 #ifdef INCLUDE_gdip_png
         /* Except the gdip-png loader which normally isn't built at all even */
         load_one_builtin_module (png);
@@ -648,6 +668,10 @@
 module (pcx);
 module (icns);
 module (jasper);
+module (svg);
+module (webp);
+module (psd);
+module (openraw);
 module (qtif);
 module (gdip_ico);
 module (gdip_wmf);
@@ -730,6 +754,18 @@
 #ifdef INCLUDE_jasper
         try_module (jasper,jasper);
 #endif
+#ifdef INCLUDE_svg
+        try_module (svg,svg);
+#endif
+#ifdef INCLUDE_webp
+        try_module (webp,webp);
+#endif
+#ifdef INCLUDE_psd
+        try_module (psd,psd);
+#endif
+#ifdef INCLUDE_openraw
+        try_module (openraw,openraw);
+#endif
 #ifdef INCLUDE_qtif
         try_module (qtif,qtif);
 #endif
@@ -739,8 +775,12 @@
         try_module (emf,gdip_emf);
         try_module (bmp,gdip_bmp);
         try_module (gif,gdip_gif);
+#ifndef INCLUDE_jpeg
         try_module (jpeg,gdip_jpeg);
+#endif
+#ifndef INCLUDE_tiff
         try_module (tiff,gdip_tiff);
+#endif
 #endif
 #ifdef INCLUDE_gdip_png
         try_module (png,gdip_png);
--- gdk-pixbuf/io-openraw.c	Mon Jan 26 14:12:06 2015
+++ gdk-pixbuf/io-openraw.c	Wed May 28 10:48:42 2014
@@ -0,0 +1,397 @@
+/*
+ * libopenraw - gdkpixbuf.c
+ *
+ * Copyright (C) 2006-2007 Hubert Figuiere
+ *
+ * This library is free software: you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation, either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+/** @brief gdkpixbuf support */
+
+#include <stdlib.h>
+#include <string.h>
+#include <glib.h>
+#define GDK_PIXBUF_ENABLE_BACKEND
+#include <gdk-pixbuf/gdk-pixbuf-io.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include <libopenraw/thumbnails.h>
+#include <libopenraw/rawfile.h>
+#include <libopenraw-gnome/gdkpixbuf.h>
+#include <libopenraw/libopenraw.h>
+#undef  GDK_PIXBUF_ENABLE_BACKEND
+
+static void pixbuf_free(guchar * data, gpointer u)
+{
+	(void)u;
+	free(data);
+}
+
+
+static GdkPixbuf *rotate_pixbuf(GdkPixbuf *tmp, int32_t orientation)
+{
+	GdkPixbuf *pixbuf = NULL;
+	switch(orientation) {
+	case 0:
+	case 1:
+		pixbuf = tmp;
+		break;
+	case 2:
+		pixbuf = gdk_pixbuf_flip(tmp, TRUE);
+		gdk_pixbuf_unref(tmp);
+		break;
+	case 3:
+		pixbuf = gdk_pixbuf_rotate_simple(tmp, GDK_PIXBUF_ROTATE_UPSIDEDOWN);
+		gdk_pixbuf_unref(tmp);		
+		break;
+	case 4:
+		pixbuf = gdk_pixbuf_rotate_simple(tmp, GDK_PIXBUF_ROTATE_UPSIDEDOWN);
+		gdk_pixbuf_unref(tmp);
+		tmp = pixbuf;
+		pixbuf = gdk_pixbuf_flip(tmp, TRUE);
+		gdk_pixbuf_unref(tmp);		
+		break;
+	case 5:
+		pixbuf =  gdk_pixbuf_rotate_simple(tmp, GDK_PIXBUF_ROTATE_CLOCKWISE);
+		gdk_pixbuf_unref(tmp);		
+		tmp = pixbuf;
+		pixbuf = gdk_pixbuf_flip(tmp, FALSE);
+		gdk_pixbuf_unref(tmp);		
+		break;
+	case 6:
+		pixbuf =  gdk_pixbuf_rotate_simple(tmp, GDK_PIXBUF_ROTATE_CLOCKWISE);
+		gdk_pixbuf_unref(tmp);		
+		break;
+	case 7:
+		pixbuf =  gdk_pixbuf_rotate_simple(tmp, GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE);
+		gdk_pixbuf_unref(tmp);		
+		tmp = pixbuf;
+		pixbuf = gdk_pixbuf_flip(tmp, FALSE);
+		gdk_pixbuf_unref(tmp);		
+		break;		
+	case 8:
+		pixbuf =  gdk_pixbuf_rotate_simple(tmp, GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE);
+		gdk_pixbuf_unref(tmp);		
+		break;		
+	default:
+		break;
+	}
+	return pixbuf;
+}
+
+
+static GdkPixbuf *_or_thumbnail_to_pixbuf(ORThumbnailRef thumbnail, 
+										  int32_t orientation)
+{
+	GdkPixbuf *tmp = NULL;
+	
+	const guchar * buf;
+	or_data_type format = or_thumbnail_format(thumbnail);
+	buf = (const guchar *)or_thumbnail_data(thumbnail);
+	
+	switch (format)
+	{
+	case OR_DATA_TYPE_PIXMAP_8RGB:
+	{
+		uint32_t x, y;
+		size_t buf_size;
+		guchar * data;
+
+		buf_size = or_thumbnail_data_size(thumbnail);
+		data = (guchar*)malloc(buf_size);
+		memcpy(data, buf, buf_size);
+		or_thumbnail_dimensions(thumbnail, &x, &y);
+		
+		tmp = gdk_pixbuf_new_from_data(data, 
+									   GDK_COLORSPACE_RGB,
+									   FALSE, 8, x, y, x * 3, 
+									   pixbuf_free, NULL);
+		break;
+	}
+	case OR_DATA_TYPE_JPEG:
+	case OR_DATA_TYPE_TIFF:
+	case OR_DATA_TYPE_PNG:
+	{
+		GdkPixbufLoader *loader = NULL;
+		size_t count = or_thumbnail_data_size(thumbnail);
+		loader = gdk_pixbuf_loader_new();
+		if (loader != NULL) {
+			gdk_pixbuf_loader_write(loader, buf, count, NULL);
+			gdk_pixbuf_loader_close(loader, NULL);
+			tmp = gdk_pixbuf_loader_get_pixbuf(loader);
+		}
+		break;
+	}
+	default: 
+		break;
+	}
+	return rotate_pixbuf(tmp, orientation);
+}
+
+
+
+
+GdkPixbuf *or_thumbnail_to_pixbuf(ORThumbnailRef thumbnail)
+{
+	return _or_thumbnail_to_pixbuf(thumbnail, 0); 
+}
+
+
+static GdkPixbuf *_or_gdkpixbuf_extract_thumbnail(const char *path, 
+												  uint32_t preferred_size, 
+												  gboolean rotate)
+{
+	ORRawFileRef rf;
+	int32_t orientation = 0;
+	GdkPixbuf *pixbuf = NULL;
+	or_error err = OR_ERROR_NONE;
+	ORThumbnailRef thumbnail = NULL;
+
+	rf = or_rawfile_new(path, OR_RAWFILE_TYPE_UNKNOWN);
+	if(rf) {
+		if(rotate) {
+			orientation = or_rawfile_get_orientation(rf);
+		}
+		thumbnail = or_thumbnail_new();
+		err = or_rawfile_get_thumbnail(rf, preferred_size,
+									   thumbnail);
+		if (err == OR_ERROR_NONE)	{
+			pixbuf = _or_thumbnail_to_pixbuf(thumbnail, orientation);
+		}
+		else {
+			g_debug("or_get_extract_thumbnail() failed with %d.", err);
+		}
+		err = or_thumbnail_release(thumbnail);
+		if (err != OR_ERROR_NONE) {
+			g_warning("or_thumbnail_release() failed with %d", err);
+		}
+		or_rawfile_release(rf);
+	}
+
+	return pixbuf;
+}
+
+
+
+GdkPixbuf *or_gdkpixbuf_extract_thumbnail(const char *path, uint32_t preferred_size)
+{
+	return _or_gdkpixbuf_extract_thumbnail(path, preferred_size, FALSE);
+}
+
+GdkPixbuf *or_gdkpixbuf_extract_rotated_thumbnail(const char *path, uint32_t preferred_size)
+{
+	return _or_gdkpixbuf_extract_thumbnail(path, preferred_size, TRUE);
+}
+
+/*
+ * libopenraw - pixbuf-loader.c
+ *
+ * Copyright (C) 2008 Hubert Figuiere
+ *
+ * This library is free software: you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation, either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+
+/** @brief gdkpixbuf loader for RAW files */
+#ifndef INCLUDE_openraw
+#define MODULE_ENTRY(function) G_MODULE_EXPORT void function
+#else
+#define MODULE_ENTRY(function) void _gdk_pixbuf__openraw_ ## function
+#endif
+
+static void pixbuf_free2(guchar * data, gpointer u)
+{
+    ORBitmapDataRef b = (ORBitmapDataRef)u;
+    (void)data;
+    or_bitmapdata_release(b);
+}
+
+#if 0
+static GdkPixbuf * 
+gdk_pixbuf__or_image_load(FILE *f, GError **error)
+{
+    (void)f;
+    (void)error;
+    return NULL;
+}
+#endif
+
+
+typedef struct {
+    GdkPixbufModuleSizeFunc     size_func;
+    GdkPixbufModulePreparedFunc prepared_func;
+    GdkPixbufModuleUpdatedFunc  updated_func;
+    gpointer                    user_data;
+    GByteArray                 *data;
+} OrContext;
+
+static gpointer
+gdk_pixbuf__or_image_begin_load (GdkPixbufModuleSizeFunc size_func,
+                                 GdkPixbufModulePreparedFunc prepared_func,
+                                 GdkPixbufModuleUpdatedFunc  updated_func,
+                                 gpointer user_data,
+                                 GError **error)
+{
+    OrContext *context = (OrContext*)calloc(1, sizeof(OrContext));
+
+    (void)error;
+
+    context->size_func = size_func;
+    context->prepared_func = prepared_func;
+    context->updated_func = updated_func;
+    context->user_data = user_data;
+    context->data = g_byte_array_new();
+
+    return (gpointer)context;
+}
+
+static gboolean
+gdk_pixbuf__or_image_load_increment (gpointer data,
+                                     const guchar *buf, guint size,
+                                     GError **error)
+{
+    OrContext *context = (OrContext*)data;
+    (void)error;
+    g_byte_array_append (context->data, buf, size);
+    return TRUE;
+}
+
+static gboolean
+gdk_pixbuf__or_image_stop_load (gpointer data, GError **error)
+{
+    OrContext *context = (OrContext*)data;
+    gboolean result = FALSE;
+	
+    GdkPixbuf *pixbuf = NULL;
+    ORRawFileRef raw_file = NULL;
+    (void)error;
+
+    raw_file = or_rawfile_new_from_memory(context->data->data, context->data->len,
+                                          OR_DATA_TYPE_NONE);
+	
+    if(raw_file) {
+        or_error err;
+        ORBitmapDataRef bitmapdata = or_bitmapdata_new();
+        err = or_rawfile_get_rendered_image(raw_file, bitmapdata, 0);
+        if(err == OR_ERROR_NONE) {
+            uint32_t x,y;
+            x = y = 0;
+            or_bitmapdata_dimensions(bitmapdata, &x, &y);
+            pixbuf = gdk_pixbuf_new_from_data(or_bitmapdata_data(bitmapdata), 
+                                              GDK_COLORSPACE_RGB,
+                                              FALSE, 8, x, y, 
+                                              (x - 2) * 3, 
+                                              pixbuf_free2, bitmapdata);
+        }
+        or_rawfile_release(raw_file);
+
+        if (context->prepared_func != NULL) {
+            (*context->prepared_func) (pixbuf, NULL, context->user_data);
+        }
+        if (context->updated_func != NULL) {
+            (*context->updated_func) (pixbuf, 0, 0,
+                                      gdk_pixbuf_get_width(pixbuf),
+                                      gdk_pixbuf_get_height(pixbuf),
+                                      context->user_data);
+        }
+        result = TRUE;
+    }
+
+
+    g_byte_array_free(context->data, TRUE);
+    free(context);
+    return result;
+}
+
+MODULE_ENTRY (fill_vtable) (GdkPixbufModule *module)
+{
+    module->begin_load     = gdk_pixbuf__or_image_begin_load;
+    module->stop_load      = gdk_pixbuf__or_image_stop_load;
+    module->load_increment = gdk_pixbuf__or_image_load_increment;
+
+    module->load           = NULL; /*gdk_pixbuf__or_image_load;*/
+}
+
+
+MODULE_ENTRY (fill_info) (GdkPixbufFormat *info)
+{
+    static GdkPixbufModulePattern signature[] = {
+        { "MM \x2a", "  z ", 80 }, /* TIFF */
+        { "II\x2a \x10   CR\x02 ", "   z zzz   z", 100 }, /* CR2 */
+        { "II\x2a ", "   z", 80 }, /* TIFF */
+        { "IIRO", "    ", 100 },   /* ORF */
+        { " MRM", "z   ", 100 },   /* MRW */
+        { "II\x1a   HEAPCCDR", "   zzz        ", 100 }, /* CRW */
+        { NULL, NULL, 0 }
+    };
+	
+    static gchar *mime_types[] = {
+        "image/x-adobe-dng",
+        "image/x-canon-cr2",
+        "image/x-canon-crw",
+        "image/x-nikon-nef",
+        "image/x-olympus-orf",
+        "image/x-pentax-pef",
+        "image/x-sony-arw",
+        "image/x-epson-erf",
+        "image/x-minolta-mrw",
+        NULL
+    };
+	
+    static gchar *extensions[] = {
+        "dng",
+        "cr2",
+        "crw",
+        "nef",
+        "orf",
+        "pef",
+        "arw",
+        "erf",
+        "mrw",
+        NULL
+    };
+	
+    info->name        = "Digital camera RAW";
+    info->signature   = signature;
+    info->description = "Digital camera RAW images loader.";
+    info->mime_types  = mime_types;
+    info->extensions  = extensions;
+    info->flags       = 0;
+    info->license     = "LGPL";
+}
+
+
+/*
+  Local Variables:
+  mode:c++
+  c-file-style:"stroustrup"
+  c-file-offsets:((innamespace . 0))
+  indent-tabs-mode:nil
+  fill-column:80
+  End:
+*/
+
+
--- gdk-pixbuf/io-psd.c	Mon Jan 26 14:12:39 2015
+++ gdk-pixbuf/io-psd.c	Wed May 28 10:48:42 2014
@@ -0,0 +1,598 @@
+/* -*- mode: C; c-file-style: "linux" -*- */
+/* GdkPixbuf library - PSD image loader
+ *
+ * Copyright (C) 2008 Jan Dudek
+ *
+ * Authors: Jan Dudek <jd@jandudek.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * TODO
+ * - use http://library.gnome.org/devel/glib/unstable/glib-Byte-Order-Macros.html
+ * - report errors from parse_psd_header
+ * - other color modes (CMYK at least)
+ * - i18n
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <gdk-pixbuf/gdk-pixbuf-io.h>
+#include <glib/gstdio.h>
+
+
+typedef struct
+{
+	guchar  signature[4];  /* file ID, always "8BPS" */
+	guint16 version;       /* version number, always 1 */
+	guchar  resetved[6];
+	guint16 channels;      /* number of color channels (1-24) */
+	guint32 rows;          /* height of image in pixels (1-30000) */
+	guint32 columns;       /* width of image in pixels (1-30000) */
+	guint16 depth;         /* number of bits per channel (1, 8, and 16) */
+	guint16 color_mode;    /* color mode as defined below */
+} PsdHeader;
+
+#define PSD_HEADER_SIZE 26
+
+typedef enum
+{
+	PSD_MODE_MONO = 0,
+	PSD_MODE_GRAYSCALE = 1,
+	PSD_MODE_INDEXED = 2,
+	PSD_MODE_RGB = 3,
+	PSD_MODE_CMYK = 4,
+	PSD_MODE_MULTICHANNEL = 7,
+	PSD_MODE_DUOTONE = 8,
+	PSD_MODE_LAB = 9,
+} PsdColorMode;
+
+typedef enum
+{
+	PSD_COMPRESSION_NONE = 0,
+	PSD_COMPRESSION_RLE = 1
+} PsdCompressionType;
+
+typedef enum
+{
+	PSD_STATE_HEADER,
+	PSD_STATE_COLOR_MODE_BLOCK,
+	PSD_STATE_RESOURCES_BLOCK,
+	PSD_STATE_LAYERS_BLOCK,
+	PSD_STATE_COMPRESSION,
+	PSD_STATE_LINES_LENGTHS,
+	PSD_STATE_CHANNEL_DATA,
+	PSD_STATE_DONE
+} PsdReadState;
+
+typedef struct
+{
+	PsdReadState       state;
+	
+	GdkPixbuf*                  pixbuf;
+
+	GdkPixbufModuleSizeFunc     size_func;
+	GdkPixbufModuleUpdatedFunc  updated_func;
+	GdkPixbufModulePreparedFunc prepared_func; 
+	gpointer                    user_data;
+
+	guchar*            buffer;
+	guint              bytes_read;
+	guint32            bytes_to_skip;
+	gboolean           bytes_to_skip_known;
+
+	guint32            width;         /* width of image in pixels (1-30000) */
+	guint32            height;        /* height of image in pixels (1-30000) */
+	guint16            channels;      /* number of color channels (1-24) */
+	guint16            depth;         /* number of bits per channel (1/8/16) */
+	PsdColorMode       color_mode;
+	PsdCompressionType compression;
+
+	guchar**           ch_bufs;       /* channels buffers */
+	guint              curr_ch;       /* current channel */
+	guint              curr_row;
+	guint              pos;           // redundant?
+	guint16*           lines_lengths;
+	gboolean           finalized;
+	gboolean           use_alpha;
+} PsdContext;
+
+
+static guint16
+read_uint16 (guchar* buf)
+{
+	return (buf[0] << 8) | buf[1];
+}
+
+static guint32
+read_uint32 (guchar* buf)
+{
+	return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+}
+
+
+/*
+ * Parse Psdheader from buffer
+ *
+ * str is expected to be at least PSD_HEADER_SIZE long
+ */
+static PsdHeader
+psd_parse_header (guchar* str)
+{
+	PsdHeader hd;
+	
+	memcpy(hd.signature, str, 4);
+	hd.version = read_uint16(str + 4);
+	hd.channels = read_uint16(str + 12);
+	hd.rows = read_uint32(str + 14);
+	hd.columns = read_uint32(str + 18);
+	hd.depth = read_uint16(str + 22);
+	hd.color_mode = read_uint16(str + 24);
+
+	return hd;
+}
+
+/*
+ * Attempts to read bytes_needed bytes from data and stores them in buffer.
+ *
+ * Returns true if there were enough bytes and false otherwise
+ * (which means we need to call feed_buffer again)
+ */
+static gboolean
+feed_buffer (guchar*        buffer,
+             guint*         bytes_read,
+             const guchar** data,
+             guint*         size,
+             guint          bytes_needed)
+{
+	gint how_many = bytes_needed - *bytes_read;
+	if (how_many > *size) {
+		how_many = *size;
+	}
+	memcpy(buffer + *bytes_read, *data, how_many);
+	*bytes_read += how_many;
+	*data += how_many;
+	*size -= how_many;
+	return (*bytes_read == bytes_needed);
+}
+
+/*
+ * Attempts to read size of the block and then skip this block.
+ *
+ * Returns true when finishes consuming block data, otherwise false
+ * (false means we need to call skip_block again)
+ */
+static gboolean
+skip_block (PsdContext* context, const guchar** data, guint* size)
+{
+	static guint counter;
+
+	if (!context->bytes_to_skip_known) {
+		context->bytes_read = 0;
+		if (feed_buffer(context->buffer, &context->bytes_read, data, size, 4)) {
+			context->bytes_to_skip = read_uint32(context->buffer);
+			context->bytes_to_skip_known = TRUE;
+			counter = 0;
+		} else {
+			return FALSE;
+		}
+	}
+	if (*size < context->bytes_to_skip) {
+		*data += *size;
+		context->bytes_to_skip -= *size;
+		counter += *size;
+		*size = 0;
+		return FALSE;
+	} else {
+		counter += context->bytes_to_skip;
+		*size -= context->bytes_to_skip;
+		*data += context->bytes_to_skip;
+		return TRUE;
+	}
+}
+
+/*
+ * Decodes RLE-compressed data
+ */
+static void
+decompress_line(const guchar* src, guint line_length, guchar* dest)
+{
+	guint16 bytes_read = 0;
+	while (bytes_read < line_length) {
+		gchar byte = src[bytes_read];
+		++bytes_read;
+	
+		if (byte == -128) {
+			continue;
+		} else if (byte > -1) {
+			gint count = byte + 1;
+		
+			// copy next count bytes
+			for (int k = 0; k < count; ++k) {
+				*dest = src[bytes_read];
+				++dest;
+				++bytes_read;
+			}
+		} else {
+			gint count = -byte + 1;
+		
+			// copy next byte count times
+			guchar next_byte = src[bytes_read];
+			++bytes_read; 
+			for (int k = 0; k < count; ++k) {
+				*dest = next_byte;
+				++dest;
+			}
+		}
+	}
+}
+
+static void
+reset_context_buffer(PsdContext* ctx)
+{
+	ctx->bytes_read = 0;
+	ctx->bytes_to_skip = 0;
+	ctx->bytes_to_skip_known = FALSE;
+}
+
+static gpointer
+gdk_pixbuf__psd_image_begin_load (GdkPixbufModuleSizeFunc size_func,
+                                  GdkPixbufModulePreparedFunc prepared_func,
+                                  GdkPixbufModuleUpdatedFunc updated_func,
+                                  gpointer user_data,
+                                  GError **error)
+{
+	PsdContext* context = g_malloc(sizeof(PsdContext));
+	if (context == NULL) {
+		g_set_error (
+			error,
+			GDK_PIXBUF_ERROR,
+			GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,
+			("Not enough memory"));
+		return NULL;
+	}
+	context->size_func = size_func;
+	context->prepared_func = prepared_func;
+	context->updated_func = updated_func;
+	context->user_data = user_data;
+	
+	context->state = PSD_STATE_HEADER;
+
+	// we'll allocate larger buffer once we know image size
+	context->buffer = g_malloc(PSD_HEADER_SIZE);
+	reset_context_buffer(context);
+
+	context->ch_bufs = NULL;
+	context->curr_ch = 0;
+	context->curr_row = 0;
+	context->pos = 0;
+	context->lines_lengths = NULL;
+	context->finalized = FALSE;
+	context->use_alpha = FALSE;
+
+	return (gpointer) context;
+}
+
+static gboolean
+gdk_pixbuf__psd_image_stop_load (gpointer context_ptr, GError **error)
+{
+	PsdContext *ctx = (PsdContext *) context_ptr;
+	gboolean retval = TRUE;
+
+	if (ctx->state != PSD_STATE_DONE) {
+		g_set_error (
+			error,
+			GDK_PIXBUF_ERROR,
+			GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+			("PSD file was corrupted or incomplete."));
+		retval = FALSE;
+	}
+	
+	g_free(ctx->buffer);
+	g_free(ctx->lines_lengths);
+	if (ctx->ch_bufs) {
+		for (int i = 0; i < ctx->channels; i++) {
+			g_free(ctx->ch_bufs[i]);
+		}
+	}
+	g_free(ctx);
+	
+	return retval;
+}
+
+
+static gboolean
+gdk_pixbuf__psd_image_load_increment (gpointer      context_ptr,
+                                      const guchar *data,
+                                      guint         size,
+                                      GError      **error)
+{
+	PsdContext* ctx = (PsdContext*) context_ptr;
+	
+	while (size > 0) {
+		switch (ctx->state) {
+			case PSD_STATE_HEADER:
+				if (feed_buffer(
+						ctx->buffer, &ctx->bytes_read,
+						&data, &size, PSD_HEADER_SIZE))
+				{
+					PsdHeader hd = psd_parse_header(ctx->buffer);
+
+					ctx->width = hd.columns;
+					ctx->height = hd.rows;
+					ctx->channels = hd.channels;
+					ctx->depth = hd.depth;
+					ctx->color_mode = hd.color_mode;
+					
+					/*
+					if (ctx->color_mode == PSD_MODE_RGB && ctx->channels == 4) {
+						ctx->use_alpha = TRUE;
+					}*/
+					
+					//g_message("color_mode=%d, channels=%d, depth=%d",
+					//	ctx->color_mode, ctx->channels, ctx->depth);
+					
+					if (ctx->color_mode != PSD_MODE_RGB
+					    //&& ctx->color_mode != PSD_MODE_CMYK
+					) {
+						g_set_error (error, GDK_PIXBUF_ERROR,
+							GDK_PIXBUF_ERROR_UNKNOWN_TYPE,
+							("Unsupported color mode"));
+						return FALSE;
+					}
+					
+					if (ctx->depth != 8) {
+						g_set_error (error, GDK_PIXBUF_ERROR,
+							GDK_PIXBUF_ERROR_UNKNOWN_TYPE,
+							("Unsupported color depth"));
+						return FALSE;
+					}
+					
+					if (ctx->size_func) {
+						gint w = ctx->width;
+						gint h = ctx->height;
+						ctx->size_func(&w, &h, ctx->user_data);
+						if (w == 0 || h == 0) {
+							return FALSE;
+						}
+					}
+					
+					// we need buffer that can contain one channel data of one
+					// row in RLE compressed format. 2*width should be enough
+					g_free(ctx->buffer);
+					ctx->buffer = g_malloc(ctx->width * 2);
+					
+					// this will be needed for RLE decompression
+					ctx->lines_lengths =
+						g_malloc(2 * ctx->channels * ctx->height);
+					
+					ctx->pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB,
+						ctx->use_alpha, 8, ctx->width, ctx->height);
+
+					if (ctx->lines_lengths == NULL || ctx->buffer == NULL ||
+						ctx->pixbuf == NULL)
+					{
+						g_set_error (error, GDK_PIXBUF_ERROR,
+							GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,
+							("Insufficient memory to load PSD image file"));
+						return FALSE;
+					}
+					
+					// create separate buffers for each channel
+					ctx->ch_bufs = g_malloc(sizeof(guchar*) * ctx->channels);
+					for (int i = 0; i <	ctx->channels; i++) {
+						ctx->ch_bufs[i] =
+							g_malloc(ctx->width * ctx->height);
+
+						if (ctx->ch_bufs[i] == NULL) {
+							g_set_error (error, GDK_PIXBUF_ERROR,
+								GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,
+								("Insufficient memory to load PSD image file"));
+							return FALSE;
+						}	
+					}
+					
+					ctx->prepared_func(ctx->pixbuf, NULL, ctx->user_data);
+					
+					ctx->state = PSD_STATE_COLOR_MODE_BLOCK;
+					reset_context_buffer(ctx);
+				}
+				break;
+			case PSD_STATE_COLOR_MODE_BLOCK:
+				if (skip_block(ctx, &data, &size)) {
+					ctx->state = PSD_STATE_RESOURCES_BLOCK;
+					reset_context_buffer(ctx);
+				}
+				break;
+			case PSD_STATE_RESOURCES_BLOCK:
+				if (skip_block(ctx, &data, &size)) {
+					ctx->state = PSD_STATE_LAYERS_BLOCK;
+					reset_context_buffer(ctx);
+				}
+				break;
+			case PSD_STATE_LAYERS_BLOCK:
+				if (skip_block(ctx, &data, &size)) {
+					ctx->state = PSD_STATE_COMPRESSION;
+					reset_context_buffer(ctx);
+				}
+				break;
+			case PSD_STATE_COMPRESSION:
+				if (feed_buffer(ctx->buffer, &ctx->bytes_read, &data, &size, 2))
+				{
+					ctx->compression = read_uint16(ctx->buffer);
+
+					if (ctx->compression == PSD_COMPRESSION_RLE) {
+						ctx->state = PSD_STATE_LINES_LENGTHS;
+						reset_context_buffer(ctx);
+					} else if (ctx->compression == PSD_COMPRESSION_NONE) {
+						ctx->state = PSD_STATE_CHANNEL_DATA;
+					} else {
+						g_set_error (error, GDK_PIXBUF_ERROR,
+							GDK_PIXBUF_ERROR_UNKNOWN_TYPE,
+							("Unsupported compression type"));
+						return FALSE;
+					}
+				}
+				break;
+			case PSD_STATE_LINES_LENGTHS:
+				if (feed_buffer(
+						(guchar*) ctx->lines_lengths, &ctx->bytes_read, &data,
+						 &size,	2 * ctx->height * ctx->channels))
+				{
+					// convert from different endianness
+					for (int i = 0; i <	ctx->height * ctx->channels; i++) {
+						ctx->lines_lengths[i] = read_uint16(
+							(guchar*) &ctx->lines_lengths[i]);
+					}
+					ctx->state = PSD_STATE_CHANNEL_DATA;
+					reset_context_buffer(ctx);
+				}
+				break;
+			case PSD_STATE_CHANNEL_DATA:
+				{
+					guint line_length = ctx->width;
+					if (ctx->compression == PSD_COMPRESSION_RLE) {
+						line_length = ctx->lines_lengths[
+							ctx->curr_ch * ctx->height + ctx->curr_row];
+					}
+					
+					if (feed_buffer(ctx->buffer, &ctx->bytes_read, &data, &size,
+							line_length))
+					{
+						reset_context_buffer(ctx);
+					
+						if (ctx->compression == PSD_COMPRESSION_RLE) {
+							decompress_line(ctx->buffer, line_length,
+								ctx->ch_bufs[ctx->curr_ch] + ctx->pos
+							);
+						} else {
+							memcpy(ctx->ch_bufs[ctx->curr_ch] + ctx->pos,
+								ctx->buffer, ctx->width);
+						}
+
+						ctx->pos += ctx->width;
+						++ctx->curr_row;
+					
+						if (ctx->curr_row >= ctx->height) {
+							++ctx->curr_ch;
+							ctx->curr_row = 0;
+							ctx->pos = 0;
+							if (ctx->curr_ch >= ctx->channels) {
+								ctx->state = PSD_STATE_DONE;
+							}
+						}
+					}
+				}
+				break;
+			case PSD_STATE_DONE:
+			default:
+				size = 0;
+				break;
+		}
+	}
+	
+	if (ctx->state == PSD_STATE_DONE && !ctx->finalized) {
+		// convert or copy channel buffers to our GdkPixbuf
+		if (ctx->color_mode == PSD_MODE_RGB && !ctx->use_alpha) {
+			guchar* pixels = gdk_pixbuf_get_pixels(ctx->pixbuf);
+			for (int i = 0; i < ctx->height; i++) {
+				for (int j = 0; j < ctx->width; j++) {
+					pixels[3*j+0] = ctx->ch_bufs[0][ctx->width*i + j];
+					pixels[3*j+1] = ctx->ch_bufs[1][ctx->width*i + j];
+					pixels[3*j+2] = ctx->ch_bufs[2][ctx->width*i + j];
+				}
+				pixels += gdk_pixbuf_get_rowstride(ctx->pixbuf);
+			}
+		} else if (ctx->color_mode == PSD_MODE_RGB && ctx->use_alpha) {
+			guchar* pixels = gdk_pixbuf_get_pixels(ctx->pixbuf);
+			for (int i = 0; i < ctx->height; i++) {
+				for (int j = 0; j < ctx->width; j++) {
+					pixels[4*j+0] = ctx->ch_bufs[0][ctx->width*i + j];
+					pixels[4*j+1] = ctx->ch_bufs[1][ctx->width*i + j];
+					pixels[4*j+2] = ctx->ch_bufs[2][ctx->width*i + j];
+					pixels[4*j+3] = ctx->ch_bufs[3][ctx->width*i + j];
+				}
+				pixels += gdk_pixbuf_get_rowstride(ctx->pixbuf);
+			}
+		} else if (ctx->color_mode == PSD_MODE_CMYK) {
+			// unfortunately, this doesn't seem to work correctly...
+		
+			guchar* pixels = gdk_pixbuf_get_pixels(ctx->pixbuf);
+			for (int i = 0; i < ctx->height; i++) {
+				for (int j = 0; j < ctx->width; j++) {
+					double c = 1.0 -
+						(double) ctx->ch_bufs[0][ctx->width*i + j] / 255.0;
+					double m = 1.0 -
+						(double) ctx->ch_bufs[1][ctx->width*i + j] / 255.0;
+					double y = 1.0 -
+						(double) ctx->ch_bufs[2][ctx->width*i + j] / 255.0;
+					double k = 1.0 -
+						(double) ctx->ch_bufs[3][ctx->width*i + j] / 255.0;
+					
+					pixels[3*j+0] = (1.0 - (c * (1.0 - k) + k)) * 255.0;
+					pixels[3*j+1] = (1.0 - (m * (1.0 - k) + k)) * 255.0;
+					pixels[3*j+2] = (1.0 - (y * (1.0 - k) + k)) * 255.0;
+				}
+				pixels += gdk_pixbuf_get_rowstride(ctx->pixbuf);
+			}
+		}
+		ctx->finalized = TRUE;
+	}
+	
+	return TRUE;
+}
+
+
+#ifndef INCLUDE_psd
+#define MODULE_ENTRY(function) G_MODULE_EXPORT void function
+#else
+#define MODULE_ENTRY(function) void _gdk_pixbuf__psd_ ## function
+#endif
+
+MODULE_ENTRY (fill_vtable) (GdkPixbufModule* module)
+{
+	module->begin_load = gdk_pixbuf__psd_image_begin_load;
+	module->stop_load = gdk_pixbuf__psd_image_stop_load;
+	module->load_increment = gdk_pixbuf__psd_image_load_increment;
+}
+
+MODULE_ENTRY (fill_info) (GdkPixbufFormat *info)
+{
+	static GdkPixbufModulePattern signature[] = {
+		{ "8BPS", NULL, 100 },
+		{ NULL, NULL, 0 }
+	};
+	static gchar * mime_types[] = {
+		"image/x-psd",
+		NULL
+	};
+	static gchar * extensions[] = {
+		"psd",
+		NULL
+	};
+
+	info->name = "psd";
+	info->signature = signature;
+	//info->description = N_("Adobe Photoshop format");
+	info->description = "Adobe Photoshop format";
+	info->mime_types = mime_types;
+	info->extensions = extensions;
+	info->flags = GDK_PIXBUF_FORMAT_THREADSAFE;
+	info->flags = 0;
+	info->license = "LGPL";
+}
+
--- gdk-pixbuf/io-svg.c	Mon Jan 26 14:13:13 2015
+++ gdk-pixbuf/io-svg.c	Wed May 28 10:48:42 2014
@@ -0,0 +1,222 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */
+/* GdkPixbuf library - SVG image loader
+ *
+ * Copyright (C) 2002 Matthias Clasen
+ * Copyright (C) 2002-2004 Dom Lachowicz
+ *
+ * Authors: Matthias Clasen <maclas@gmx.de>
+ *          Dom Lachowicz <cinamod@hotmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more  * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+
+#include <rsvg.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+
+#include "librsvg-features.h"
+
+#define N_(string) (string)
+#define _(string) (string)
+
+typedef struct {
+        RsvgHandle                 *handle;
+
+        GdkPixbufModuleUpdatedFunc  updated_func;
+        GdkPixbufModulePreparedFunc prepared_func;
+        GdkPixbufModuleSizeFunc     size_func;
+
+        gboolean                    first_write;
+
+        gpointer                    user_data;
+} SvgContext;
+
+G_MODULE_EXPORT void fill_vtable (GdkPixbufModule *module);
+G_MODULE_EXPORT void fill_info (GdkPixbufFormat *info);
+
+enum {
+        ERROR_WRITING = 1,
+        ERROR_DISPLAYING_IMAGE
+} RsvgLoaderErrorReasons;
+
+static void
+rsvg_propegate_error (GError ** err,
+                      const char * reason,
+                      gint code)
+{
+        if (err) {
+                *err = NULL;
+                g_set_error (err, rsvg_error_quark (), code, "%s", reason);
+        }
+}
+
+static gpointer
+gdk_pixbuf__svg_image_begin_load (GdkPixbufModuleSizeFunc size_func,
+                                  GdkPixbufModulePreparedFunc prepared_func,
+                                  GdkPixbufModuleUpdatedFunc  updated_func,
+                                  gpointer user_data,
+                                  GError **error)
+{
+        SvgContext *context    = g_new0 (SvgContext, 1);
+
+        if (error)
+                *error = NULL;
+
+        context->first_write   = TRUE;
+        context->size_func     = size_func;
+
+        context->prepared_func = prepared_func;
+        context->updated_func  = updated_func;
+        context->user_data     = user_data;
+
+        return context;
+}
+
+static void
+emit_updated (SvgContext *context, GdkPixbuf *pixbuf)
+{
+        if (context->updated_func != NULL)
+                (* context->updated_func) (pixbuf,
+                                           0, 0,
+                                           gdk_pixbuf_get_width (pixbuf),
+                                           gdk_pixbuf_get_height (pixbuf),
+                                           context->user_data);
+}
+
+static void
+emit_prepared (SvgContext *context, GdkPixbuf *pixbuf)
+{
+        if (context->prepared_func != NULL)
+                (* context->prepared_func) (pixbuf, NULL, context->user_data);
+}
+
+static gboolean
+gdk_pixbuf__svg_image_load_increment (gpointer data,
+				      const guchar *buf, guint size,
+				      GError **error)
+{
+        SvgContext *context = (SvgContext *)data;
+
+        if (error)
+                *error = NULL;
+
+        if (context->first_write == TRUE) {
+                context->first_write = FALSE;
+
+                context->handle = rsvg_handle_new ();
+
+                if (!context->handle) {
+                        rsvg_propegate_error (error, _("Error displaying image"), ERROR_DISPLAYING_IMAGE);
+                        return FALSE;
+                }
+
+                rsvg_handle_set_size_callback (context->handle, context->size_func, context->user_data, NULL);
+        }
+
+        if (!context->handle) {
+                rsvg_propegate_error (error, _("Error displaying image"), ERROR_DISPLAYING_IMAGE);
+                return FALSE;
+        }
+
+        if (!rsvg_handle_write (context->handle, buf, size, error)) {
+                rsvg_propegate_error (error, _("Error writing"), ERROR_WRITING);
+                return FALSE;
+        }
+
+        return TRUE;
+}
+
+static gboolean
+gdk_pixbuf__svg_image_stop_load (gpointer data, GError **error)
+{
+        SvgContext *context = (SvgContext *)data;
+        GdkPixbuf *pixbuf;
+        gboolean result = TRUE;
+
+        if (error)
+                *error = NULL;
+
+        if (!context->handle) {
+                rsvg_propegate_error (error, _("Error displaying image"), ERROR_DISPLAYING_IMAGE);
+                return FALSE;
+        }
+
+        rsvg_handle_close (context->handle, error);
+
+        pixbuf = rsvg_handle_get_pixbuf (context->handle);
+
+        if (pixbuf != NULL) {
+                emit_prepared (context, pixbuf);
+                emit_updated (context, pixbuf);
+                g_object_unref (pixbuf);
+        }
+        else {
+                rsvg_propegate_error (error, _("Error displaying image"), ERROR_DISPLAYING_IMAGE);
+                result = FALSE;
+        }
+
+        g_object_unref (context->handle);
+        g_free (context);
+
+        return result;
+}
+
+#ifndef INCLUDE_svg
+#define MODULE_ENTRY(function) G_MODULE_EXPORT void function
+#else
+#define MODULE_ENTRY(function) void _gdk_pixbuf__svg_ ## function
+#endif
+
+MODULE_ENTRY (fill_vtable) (GdkPixbufModule *module)
+{
+        module->begin_load     = gdk_pixbuf__svg_image_begin_load;
+        module->stop_load      = gdk_pixbuf__svg_image_stop_load;
+        module->load_increment = gdk_pixbuf__svg_image_load_increment;
+}
+
+MODULE_ENTRY (fill_info) (GdkPixbufFormat *info)
+{
+        static GdkPixbufModulePattern signature[] = {
+                {  " <svg",  "*    ", 100 },
+                {  " <!DOCTYPE svg",  "*             ", 100 },
+                { NULL, NULL, 0 }
+        };
+
+        static gchar *mime_types[] = { /* yes folks, i actually have run into all of these in the wild... */
+                "image/svg+xml",
+                "image/svg",
+                "image/svg-xml",
+                "image/vnd.adobe.svg+xml",
+                "text/xml-svg",
+                "image/svg+xml-compressed",
+                NULL
+        };
+        static gchar *extensions[] = {
+                "svg",
+                "svgz",
+                "svg.gz",
+                NULL
+        };
+
+        info->name        = "svg";
+        info->signature   = signature;
+        info->description = _("Scalable Vector Graphics");
+        info->mime_types  = mime_types;
+        info->extensions  = extensions;
+        info->flags       = GDK_PIXBUF_FORMAT_SCALABLE | GDK_PIXBUF_FORMAT_THREADSAFE;
+        info->license     = "LGPL";
+}
--- gdk-pixbuf/io-webp.c	Mon Jan 26 14:13:41 2015
+++ gdk-pixbuf/io-webp.c	Wed May 28 10:51:27 2014
@@ -0,0 +1,509 @@
+/* GdkPixbuf library - WebP Image Loader
+ *
+ * Copyright (C) 2011 Alberto Ruiz
+ * Copyright (C) 2011 David Mazary
+ * Copyright (C) 2014 Premysl Janouch
+ *
+ * Authors: Alberto Ruiz <aruiz@gnome.org>
+ *          David Mazary <dmaz@vt.edu>
+ *          Premysl Janouch <p.janouch@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <webp/decode.h>
+#include <webp/encode.h>
+#include <string.h>
+
+#define GDK_PIXBUF_ENABLE_BACKEND
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#undef  GDK_PIXBUF_ENABLE_BACKEND
+
+/* Progressive loader context */
+typedef struct {
+        GdkPixbufModuleSizeFunc size_func;
+        GdkPixbufModuleUpdatedFunc update_func;
+        GdkPixbufModulePreparedFunc prepare_func;
+        WebPDecoderConfig config;
+        gpointer user_data;
+        GdkPixbuf *pixbuf;
+        gboolean got_header;
+        WebPIDecoder *idec;
+        guchar *decbuf;
+        gint last_y;
+        GError **error;
+} WebPContext;
+
+static void
+destroy_data (guchar *pixels, gpointer data)
+{
+        g_free (pixels);
+}
+
+/* Shared library entry point */
+static GdkPixbuf *
+gdk_pixbuf__webp_image_load (FILE *f, GError **error)
+{
+        GdkPixbuf * volatile pixbuf = NULL;
+        guint32 data_size;
+        guint8 *out;
+        gint w, h, ok;
+        gpointer data;
+        WebPBitstreamFeatures features;
+        gboolean use_alpha = TRUE;
+
+        /* Get data size */
+        fseek (f, 0, SEEK_END);
+        data_size = ftell(f);
+        fseek (f, 0, SEEK_SET);
+
+        /* Get data */
+        data = g_malloc (data_size);
+        ok = (fread (data, data_size, 1, f) == 1);
+        if (!ok) {
+                g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_FAILED,
+                             "Failed to read file");
+                return FALSE;
+        }
+
+        /* Take the safe route and only disable the alpha channel when
+           we're sure that there is not any. */
+        if (WebPGetFeatures (data, data_size, &features) == VP8_STATUS_OK
+            && features.has_alpha == FALSE) {
+                use_alpha = FALSE;
+        }
+
+        if (use_alpha) {
+                out = WebPDecodeRGBA (data, data_size, &w, &h);
+        } else {
+                out = WebPDecodeRGB (data, data_size, &w, &h);
+        }
+        g_free (data);
+
+        if (!out) {
+                g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_FAILED,
+                             "Cannot create WebP decoder.");
+                return FALSE;
+        }
+
+        pixbuf = gdk_pixbuf_new_from_data ((const guchar *)out,
+                                           GDK_COLORSPACE_RGB,
+                                           use_alpha,
+                                           8,
+                                           w, h,
+                                           w * (use_alpha ? 4 : 3),
+                                           destroy_data,
+                                           NULL);
+
+        if (!pixbuf) {
+                g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_FAILED,
+                             "Failed to decode image");
+                return FALSE;
+        }
+        return pixbuf;
+}
+
+static gpointer
+gdk_pixbuf__webp_image_begin_load (GdkPixbufModuleSizeFunc size_func,
+                                   GdkPixbufModulePreparedFunc prepare_func,
+                                   GdkPixbufModuleUpdatedFunc update_func,
+                                   gpointer user_data,
+                                   GError **error)
+{
+        WebPContext *context = g_new0 (WebPContext, 1);
+        context->size_func = size_func;
+        context->prepare_func = prepare_func;
+        context->update_func  = update_func;
+        context->user_data = user_data;
+        return context;
+}
+
+static gboolean
+gdk_pixbuf__webp_image_stop_load (gpointer context, GError **error)
+{
+        WebPContext *data = (WebPContext *) context;
+        g_return_val_if_fail(data != NULL, TRUE);
+        if (data->pixbuf) {
+                g_object_unref (data->pixbuf);
+        }
+        if (data->idec) {
+                WebPIDelete (data->idec);
+        }
+        if (data->decbuf) {
+                g_free (data->decbuf);
+        }
+        return TRUE;
+}
+
+// Modified WebPINewRGB() that takes a WebPDecoderConfig argument, which we
+// currently need for scaling options.
+static WebPIDecoder *
+new_rgb_decoder (WEBP_CSP_MODE mode, uint8_t* output_buffer,
+                 size_t output_buffer_size, int output_stride,
+                 WebPDecoderConfig *config)
+{
+        const int is_external_memory = (output_buffer != NULL);
+
+        if (mode >= MODE_YUV) return NULL;
+        if (!is_external_memory) {
+                // Overwrite parameters to sane values.
+                output_buffer_size = 0;
+                output_stride = 0;
+        } else {
+                // A buffer was passed. Validate the other params.
+                if (output_stride == 0 || output_buffer_size == 0) {
+                        return NULL;
+                }
+        }
+
+        config->output.colorspace = mode;
+        config->output.is_external_memory = is_external_memory;
+        config->output.u.RGBA.rgba = output_buffer;
+        config->output.u.RGBA.stride = output_stride;
+        config->output.u.RGBA.size = output_buffer_size;
+        return WebPIDecode (NULL, 0, config);
+}
+
+static gboolean
+gdk_pixbuf__webp_image_load_increment (gpointer context,
+                                       const guchar *buf, guint size,
+                                       GError **error)
+{
+        gint w, h, stride, scaled_w, scaled_h;
+        WebPContext *data = (WebPContext *) context;
+        g_return_val_if_fail(data != NULL, FALSE);
+
+        if (!data->got_header) {
+                gint rc;
+                WebPBitstreamFeatures features;
+                gboolean use_alpha = TRUE;
+
+                rc = WebPGetInfo (buf, size, &w, &h);
+                if (rc == 0) {
+                        g_set_error (error,
+                                     GDK_PIXBUF_ERROR,
+                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                                     "Cannot read WebP image header.");
+                        return FALSE;
+                }
+                data->got_header = TRUE;
+
+                scaled_w = w;
+                scaled_h = h;
+                memset (&data->config, 0, sizeof data->config);
+                if (data->size_func) {
+                        (* data->size_func) (&scaled_w, &scaled_h,
+                                             data->user_data);
+                        if (scaled_w != w || scaled_h != h) {
+                            data->config.options.use_scaling = TRUE;
+                            data->config.options.scaled_width = scaled_w;
+                            data->config.options.scaled_height = scaled_h;
+                        }
+                        w = scaled_w;
+                        h = scaled_h;
+                }
+
+                /* Take the safe route and only disable the alpha channel when
+                   we're sure that there is not any. */
+                if (WebPGetFeatures (buf, size, &features) == VP8_STATUS_OK
+                    && features.has_alpha == FALSE) {
+                        use_alpha = FALSE;
+                }
+
+                data->pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB,
+                                               use_alpha,
+                                               8,
+                                               w,
+                                               h);
+                stride = gdk_pixbuf_get_rowstride (data->pixbuf);
+
+                data->decbuf = g_try_malloc (h * stride);
+                if (!data->decbuf) {
+                        g_set_error (error,
+                                     GDK_PIXBUF_ERROR,
+                                     GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,
+                                     "Cannot allocate memory for decoded image data.");
+                        return FALSE;
+                }
+
+                data->idec = new_rgb_decoder (use_alpha ? MODE_RGBA : MODE_RGB,
+                                              data->decbuf,
+                                              h * stride,
+                                              stride,
+                                              &data->config);
+                if (!data->idec) {
+                        g_set_error (error,
+                                     GDK_PIXBUF_ERROR,
+                                     GDK_PIXBUF_ERROR_FAILED,
+                                     "Cannot create WebP decoder.");
+                        return FALSE;
+                }
+
+                if (data->prepare_func) {
+                        (* data->prepare_func) (data->pixbuf,
+                                                NULL,
+                                                data->user_data);
+                }
+        }
+
+        /* Append size bytes to decoder's buffer */
+        const VP8StatusCode status = WebPIAppend (data->idec, buf, size);
+        if (status != VP8_STATUS_SUSPENDED && status != VP8_STATUS_OK) {
+                g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
+                             "WebP decoder failed with status code %d.",
+                             status);
+                return FALSE;
+        }
+
+        /* Decode decoder's updated buffer */
+        guint8 *dec_output;
+        dec_output = WebPIDecGetRGB (data->idec, &data->last_y, &w, &h, &stride);
+        if (dec_output == NULL && status != VP8_STATUS_SUSPENDED) {
+                g_set_error(error,
+                            GDK_PIXBUF_ERROR,
+                            GDK_PIXBUF_ERROR_FAILED,
+                            "Bad inputs to WebP decoder.");
+                return FALSE;
+        }
+
+        /* Copy decoder output to pixbuf */
+        gint y, row_offset = 0;
+        guchar *dptr;
+        dptr = gdk_pixbuf_get_pixels (data->pixbuf);
+        for (y = 0; y < data->last_y; ++y, row_offset += stride) {
+                g_memmove (dptr + row_offset, dec_output + row_offset, stride);
+        }
+
+        if (data->update_func) {
+                (* data->update_func) (data->pixbuf, 0, 0,
+                                       w,
+                                       data->last_y,
+                                       data->user_data);
+        }
+        return TRUE;
+}
+
+static int
+write_file (const uint8_t* data, size_t data_size, const WebPPicture* const pic)
+{
+        FILE* const out = (FILE *) pic->custom_ptr;
+        return data_size ? (fwrite (data, data_size, 1, out) == 1) : 1;
+}
+
+typedef struct {
+        GdkPixbufSaveFunc func;
+        gpointer          data;
+} save_context;
+
+static int
+save_callback (const uint8_t* data, size_t data_size, const WebPPicture* const pic)
+{
+        save_context *env = (save_context *) pic->custom_ptr;
+        return (* env->func) (env->data, data_size, NULL, (gpointer) data);
+}
+
+static gboolean
+real_save_webp (GdkPixbuf        *pixbuf,
+                gchar           **keys,
+                gchar           **values,
+                GError          **error,
+                gboolean          to_callback,
+                FILE             *f,
+                save_context     *context)
+{
+        WebPPicture picture;
+        WebPConfig config;
+        gint w, h, rowstride, has_alpha, rc;
+        guchar *pixels;
+
+        if (!WebPPictureInit(&picture) || !WebPConfigInit(&config)) {
+                g_set_error(error,
+                            GDK_PIXBUF_ERROR,
+                            GDK_PIXBUF_ERROR_BAD_OPTION,
+                            "WebP encoder version mismatch.");
+                return FALSE;
+        }
+
+        if (keys && *keys) {
+                gchar **kiter = keys;
+                gchar **viter = values;
+
+                while (*kiter) {
+                        if (strncmp (*kiter, "quality", 7) == 0) {
+                                float quality = (float) g_ascii_strtod (*viter, NULL);
+                                if (quality < 0 || quality > 100) {
+                                        g_set_error (error,
+                                                     GDK_PIXBUF_ERROR,
+                                                     GDK_PIXBUF_ERROR_BAD_OPTION,
+                                                     "WebP quality must be a value between 0 and 100.");
+                                        return FALSE;
+                                }
+                                config.quality = quality;
+                        } else if (strncmp (*kiter, "preset", 6) == 0) {
+                                WebPPreset preset;
+                                if (strncmp (*viter, "default", 7) == 0) {
+                                        preset = WEBP_PRESET_DEFAULT;
+                                } else if (strncmp (*viter, "photo", 5) == 0) {
+                                        preset = WEBP_PRESET_PHOTO;
+                                } else if (strncmp (*viter, "picture", 7) == 0) {
+                                        preset = WEBP_PRESET_PICTURE;
+                                } else if (strncmp (*viter, "drawing", 7) == 0) {
+                                        preset = WEBP_PRESET_DRAWING;
+                                } else if (strncmp (*viter, "icon", 4) == 0) {
+                                        preset = WEBP_PRESET_ICON;
+                                } else if (strncmp (*viter, "text", 4) == 0) {
+                                        preset = WEBP_PRESET_TEXT;
+                                } else {
+                                        g_set_error (error,
+                                                     GDK_PIXBUF_ERROR,
+                                                     GDK_PIXBUF_ERROR_BAD_OPTION,
+                                                     "WebP encoder invalid preset.");
+                                        return FALSE;
+                                }
+                                if (WebPConfigPreset (&config, preset, config.quality) == 0) {
+                                         g_set_error (error,
+                                                      GDK_PIXBUF_ERROR,
+                                                      GDK_PIXBUF_ERROR_FAILED,
+                                                      "Could not initialize decoder with preset.");
+                                         return FALSE;
+                                }
+                        }
+                        ++kiter;
+                        ++viter;
+                }
+        }
+
+        if (WebPValidateConfig (&config) != 1) {
+                g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_BAD_OPTION,
+                             "Invalid encoding configuration");
+                return FALSE;
+        }
+
+        w = gdk_pixbuf_get_width (pixbuf);
+        h = gdk_pixbuf_get_height (pixbuf);
+        rowstride = gdk_pixbuf_get_rowstride (pixbuf);
+        has_alpha = gdk_pixbuf_get_has_alpha (pixbuf);
+        pixels = gdk_pixbuf_get_pixels (pixbuf);
+
+        picture.width = w;
+        picture.height = h;
+
+        if (has_alpha) {
+                rc = WebPPictureImportRGBA (&picture, pixels, rowstride);
+        } else {
+                rc = WebPPictureImportRGB (&picture, pixels, rowstride);
+        }
+        if (rc == 0) {
+                g_set_error (error,
+                             GDK_PIXBUF_ERROR,
+                             GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY,
+                             "Failed to allocate picture");
+                return FALSE;
+        }
+
+        if (to_callback) {
+                picture.writer = save_callback;
+                picture.custom_ptr = (void*) context;
+        } else {
+                picture.writer = write_file;
+                picture.custom_ptr = (void*) f;
+        }
+
+        if (WebPEncode(&config, &picture) == 0) {
+                fprintf(stderr, "Error! Cannot encode picture as WebP\n");
+        }
+
+        return TRUE;
+}
+
+static gboolean
+gdk_pixbuf__webp_image_save (FILE          *f,
+                             GdkPixbuf     *pixbuf,
+                             gchar        **keys,
+                             gchar        **values,
+                             GError       **error)
+{
+        return real_save_webp (pixbuf, keys, values, error,
+                               FALSE, f, NULL);
+}
+
+static gboolean
+gdk_pixbuf__webp_image_save_to_callback (GdkPixbufSaveFunc   save_func,
+                                         gpointer            user_data,
+                                         GdkPixbuf          *pixbuf,
+                                         gchar             **keys,
+                                         gchar             **values,
+                                         GError            **error)
+{
+        save_context *context = g_new0 (save_context, 1);
+        context->func = save_func;
+        context->data = user_data;
+        return real_save_webp (pixbuf, keys, values, error,
+                               TRUE, NULL, context);
+}
+
+#ifndef INCLUDE_webp
+#define MODULE_ENTRY(function) G_MODULE_EXPORT void function
+#else
+#define MODULE_ENTRY(function) void _gdk_pixbuf__webp_ ## function
+#endif
+
+MODULE_ENTRY (fill_vtable) (GdkPixbufModule *module)
+{
+        module->load = gdk_pixbuf__webp_image_load;
+        module->begin_load = gdk_pixbuf__webp_image_begin_load;
+        module->stop_load = gdk_pixbuf__webp_image_stop_load;
+        module->load_increment = gdk_pixbuf__webp_image_load_increment;
+        module->save = gdk_pixbuf__webp_image_save;
+        module->save_to_callback = gdk_pixbuf__webp_image_save_to_callback;
+}
+
+MODULE_ENTRY (fill_info) (GdkPixbufFormat *info)
+{
+        static GdkPixbufModulePattern signature[] = {
+                { "RIFFsizeWEBP", "    xxxx    ", 100 },
+                { NULL, NULL, 0 }
+        };
+
+        static gchar *mime_types[] = {
+                "image/webp",
+                "audio/x-riff", /* FIXME hack around systems missing mime type */
+                NULL
+        };
+
+        static gchar *extensions[] = {
+                "webp",
+                NULL
+        };
+
+        info->name        = "webp";
+        info->signature   = signature;
+        info->description = "The WebP image format";
+        info->mime_types  = mime_types;
+        info->extensions  = extensions;
+        info->flags       = GDK_PIXBUF_FORMAT_WRITABLE | GDK_PIXBUF_FORMAT_THREADSAFE;
+        info->license     = "LGPL";
+}
\ No newline at end of file
--- gdk-pixbuf/Makefile.in	Tue May 27 07:43:20 2014
+++ gdk-pixbuf/Makefile.in	Wed May 28 10:48:40 2014
@@ -330,8 +330,52 @@
 	$(LDFLAGS) -o $@
 @BUILD_DYNAMIC_MODULES_TRUE@@HAVE_JASPER_TRUE@@INCLUDE_JASPER_FALSE@am_libpixbufloader_jasper_la_rpath = -rpath \
 @BUILD_DYNAMIC_MODULES_TRUE@@HAVE_JASPER_TRUE@@INCLUDE_JASPER_FALSE@	$(loaderdir)
+libpixbufloader_svg_la_DEPENDENCIES = $(am__DEPENDENCIES_2) \
+	$(am__DEPENDENCIES_3)
+am_libpixbufloader_svg_la_OBJECTS = io-svg.lo
+libpixbufloader_svg_la_OBJECTS =  \
+	$(am_libpixbufloader_svg_la_OBJECTS)
+libpixbufloader_svg_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libpixbufloader_svg_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@BUILD_DYNAMIC_MODULES_TRUE@@HAVE_SVG_TRUE@@INCLUDE_SVG_FALSE@am_libpixbufloader_svg_la_rpath = -rpath \
+@BUILD_DYNAMIC_MODULES_TRUE@@HAVE_SVG_TRUE@@INCLUDE_SVG_FALSE@	$(loaderdir)
+libpixbufloader_webp_la_DEPENDENCIES = $(am__DEPENDENCIES_2) \
+	$(am__DEPENDENCIES_3)
+am_libpixbufloader_webp_la_OBJECTS = io-webp.lo
+libpixbufloader_webp_la_OBJECTS =  \
+	$(am_libpixbufloader_webp_la_OBJECTS)
+libpixbufloader_webp_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libpixbufloader_webp_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@BUILD_DYNAMIC_MODULES_TRUE@@HAVE_WEBP_TRUE@@INCLUDE_WEBP_FALSE@am_libpixbufloader_webp_la_rpath = -rpath \
+@BUILD_DYNAMIC_MODULES_TRUE@@HAVE_WEBP_TRUE@@INCLUDE_WEBP_FALSE@	$(loaderdir)
+libpixbufloader_psd_la_DEPENDENCIES = $(am__DEPENDENCIES_2) \
+	$(am__DEPENDENCIES_3)
+am_libpixbufloader_psd_la_OBJECTS = io-psd.lo
+libpixbufloader_psd_la_OBJECTS =  \
+	$(am_libpixbufloader_psd_la_OBJECTS)
+libpixbufloader_psd_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libpixbufloader_psd_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@BUILD_DYNAMIC_MODULES_TRUE@@HAVE_PSD_TRUE@@INCLUDE_PSD_FALSE@am_libpixbufloader_psd_la_rpath = -rpath \
+@BUILD_DYNAMIC_MODULES_TRUE@@HAVE_PSD_TRUE@@INCLUDE_PSD_FALSE@	$(loaderdir)
 libpixbufloader_jpeg_la_DEPENDENCIES = $(am__DEPENDENCIES_2) \
 	$(am__DEPENDENCIES_3)
+am_libpixbufloader_openraw_la_OBJECTS = io-openraw.lo
+libpixbufloader_openraw_la_OBJECTS =  \
+	$(am_libpixbufloader_openraw_la_OBJECTS)
+libpixbufloader_openraw_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) $(libpixbufloader_openraw_la_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@BUILD_DYNAMIC_MODULES_TRUE@@HAVE_OPENRAW_TRUE@@INCLUDE_OPENRAW_FALSE@am_libpixbufloader_openraw_la_rpath = -rpath \
+@BUILD_DYNAMIC_MODULES_TRUE@@HAVE_OPENRAW_TRUE@@INCLUDE_OPENRAW_FALSE@	$(loaderdir)
+libpixbufloader_psd_la_DEPENDENCIES = $(am__DEPENDENCIES_2) \
+	$(am__DEPENDENCIES_3)
 am_libpixbufloader_jpeg_la_OBJECTS = io-jpeg.lo
 libpixbufloader_jpeg_la_OBJECTS =  \
 	$(am_libpixbufloader_jpeg_la_OBJECTS)
@@ -523,6 +567,26 @@
 libstatic_pixbufloader_jasper_la_OBJECTS =  \
 	$(am_libstatic_pixbufloader_jasper_la_OBJECTS)
 @HAVE_JASPER_TRUE@@INCLUDE_JASPER_TRUE@am_libstatic_pixbufloader_jasper_la_rpath =
+libstatic_pixbufloader_svg_la_LIBADD =
+am_libstatic_pixbufloader_svg_la_OBJECTS = io-svg.lo
+libstatic_pixbufloader_svg_la_OBJECTS =  \
+	$(am_libstatic_pixbufloader_svg_la_OBJECTS)
+@HAVE_SVG_TRUE@@INCLUDE_SVG_TRUE@am_libstatic_pixbufloader_svg_la_rpath =
+libstatic_pixbufloader_webp_la_LIBADD =
+am_libstatic_pixbufloader_webp_la_OBJECTS = io-webp.lo
+libstatic_pixbufloader_webp_la_OBJECTS =  \
+	$(am_libstatic_pixbufloader_webp_la_OBJECTS)
+@HAVE_WEBP_TRUE@@INCLUDE_WEBP_TRUE@am_libstatic_pixbufloader_webp_la_rpath =
+libstatic_pixbufloader_psd_la_LIBADD =
+am_libstatic_pixbufloader_psd_la_OBJECTS = io-psd.lo
+libstatic_pixbufloader_psd_la_OBJECTS =  \
+	$(am_libstatic_pixbufloader_psd_la_OBJECTS)
+@HAVE_OPENRAW_TRUE@@INCLUDE_OPENRAW_TRUE@am_libstatic_pixbufloader_openraw_la_rpath =
+libstatic_pixbufloader_openraw_la_LIBADD =
+am_libstatic_pixbufloader_openraw_la_OBJECTS = io-openraw.lo
+libstatic_pixbufloader_openraw_la_OBJECTS =  \
+	$(am_libstatic_pixbufloader_openraw_la_OBJECTS)
+@HAVE_PSD_TRUE@@INCLUDE_PSD_TRUE@am_libstatic_pixbufloader_psd_la_rpath =
 libstatic_pixbufloader_jpeg_la_LIBADD =
 am_libstatic_pixbufloader_jpeg_la_OBJECTS = io-jpeg.lo
 libstatic_pixbufloader_jpeg_la_OBJECTS =  \
@@ -643,6 +707,10 @@
 	$(libpixbufloader_icns_la_SOURCES) \
 	$(libpixbufloader_ico_la_SOURCES) \
 	$(libpixbufloader_jasper_la_SOURCES) \
+	$(libpixbufloader_svg_la_SOURCES) \
+	$(libpixbufloader_webp_la_SOURCES) \
+	$(libpixbufloader_psd_la_SOURCES) \
+	$(libpixbufloader_openraw_la_SOURCES) \
 	$(libpixbufloader_jpeg_la_SOURCES) \
 	$(libpixbufloader_pcx_la_SOURCES) \
 	$(libpixbufloader_png_la_SOURCES) \
@@ -667,6 +735,10 @@
 	$(libstatic_pixbufloader_icns_la_SOURCES) \
 	$(libstatic_pixbufloader_ico_la_SOURCES) \
 	$(libstatic_pixbufloader_jasper_la_SOURCES) \
+	$(libstatic_pixbufloader_svg_la_SOURCES) \
+	$(libstatic_pixbufloader_webp_la_SOURCES) \
+	$(libstatic_pixbufloader_psd_la_SOURCES) \
+	$(libstatic_pixbufloader_openraw_la_SOURCES) \
 	$(libstatic_pixbufloader_jpeg_la_SOURCES) \
 	$(libstatic_pixbufloader_pcx_la_SOURCES) \
 	$(libstatic_pixbufloader_pixdata_la_SOURCES) \
@@ -719,6 +791,10 @@
 	$(libstatic_pixbufloader_icns_la_SOURCES) \
 	$(libstatic_pixbufloader_ico_la_SOURCES) \
 	$(libstatic_pixbufloader_jasper_la_SOURCES) \
+	$(libstatic_pixbufloader_svg_la_SOURCES) \
+	$(libstatic_pixbufloader_webp_la_SOURCES) \
+	$(libstatic_pixbufloader_psd_la_SOURCES) \
+	$(libstatic_pixbufloader_openraw_la_SOURCES) \
 	$(libstatic_pixbufloader_jpeg_la_SOURCES) \
 	$(libstatic_pixbufloader_pcx_la_SOURCES) \
 	$(libstatic_pixbufloader_pixdata_la_SOURCES) \
@@ -1330,6 +1406,38 @@
 libpixbufloader_jasper_la_LIBADD = $(LIBJASPER) $(module_libs)
 
 #
+# The SVG loader
+#
+libstatic_pixbufloader_svg_la_SOURCES = io-svg.c
+libpixbufloader_svg_la_SOURCES = io-svg.c
+libpixbufloader_svg_la_LDFLAGS = -avoid-version -module $(no_undefined)
+libpixbufloader_svg_la_LIBADD = $(LIBSVG) $(module_libs)
+
+#
+# The WebP loader
+#
+libstatic_pixbufloader_webp_la_SOURCES = io-webp.c
+libpixbufloader_webp_la_SOURCES = io-webp.c
+libpixbufloader_webp_la_LDFLAGS = -avoid-version -module $(no_undefined)
+libpixbufloader_webp_la_LIBADD = $(LIBWEBP) $(module_libs)
+
+#
+# The PSD loader
+#
+libstatic_pixbufloader_psd_la_SOURCES = io-psd.c
+libpixbufloader_psd_la_SOURCES = io-psd.c
+libpixbufloader_psd_la_LDFLAGS = -avoid-version -module $(no_undefined)
+libpixbufloader_psd_la_LIBADD = $(LIBPSD) $(module_libs)
+
+#
+# The OPENRAW loader
+#
+libstatic_pixbufloader_openraw_la_SOURCES = io-openraw.c
+libpixbufloader_openraw_la_SOURCES = io-openraw.c
+libpixbufloader_openraw_la_LDFLAGS = -avoid-version -module $(no_undefined)
+libpixbufloader_openraw_la_LIBADD = $(LIBOPENRAW) $(module_libs)
+
+#
 # The QTIF loader
 #
 libstatic_pixbufloader_qtif_la_SOURCES = io-qtif.c
@@ -1500,6 +1608,14 @@
 @INCLUDE_PCX_FALSE@PCX_LIB = libpixbufloader-pcx.la
 @INCLUDE_ICNS_TRUE@STATIC_ICNS_LIB = libstatic-pixbufloader-icns.la
 @INCLUDE_ICNS_FALSE@ICNS_LIB = libpixbufloader-icns.la
+@INCLUDE_SVG_TRUE@STATIC_SVG_LIB = libstatic-pixbufloader-svg.la
+@INCLUDE_SVG_FALSE@SVG_LIB = libpixbufloader-svg.la
+@INCLUDE_WEBP_TRUE@STATIC_webp_LIB = libstatic-pixbufloader-webp.la
+@INCLUDE_WEBP_FALSE@WEBP_LIB = libpixbufloader-webp.la
+@INCLUDE_PSD_TRUE@STATIC_PSD_LIB = libstatic-pixbufloader-psd.la
+@INCLUDE_PSD_FALSE@PSD_LIB = libpixbufloader-psd.la
+@INCLUDE_OPENRAW_TRUE@STATIC_OPENRAW_LIB = libstatic-pixbufloader-openraw.la
+@INCLUDE_OPENRAW_FALSE@OPENRAW_LIB = libpixbufloader-openraw.la
 @HAVE_JASPER_TRUE@@INCLUDE_JASPER_TRUE@STATIC_JASPER_LIB = libstatic-pixbufloader-jasper.la
 @HAVE_JASPER_TRUE@@INCLUDE_JASPER_FALSE@JASPER_LIB = libpixbufloader-jasper.la
 @INCLUDE_QTIF_TRUE@STATIC_QTIF_LIB = libstatic-pixbufloader-qtif.la
@@ -1524,6 +1640,10 @@
 @BUILD_DYNAMIC_MODULES_TRUE@	$(ICNS_LIB)	\
 @BUILD_DYNAMIC_MODULES_TRUE@	$(PCX_LIB)	\
 @BUILD_DYNAMIC_MODULES_TRUE@	$(JASPER_LIB)	\
+@BUILD_DYNAMIC_MODULES_TRUE@	$(SVG_LIB)	\
+@BUILD_DYNAMIC_MODULES_TRUE@	$(WEBP_LIB)	\
+@BUILD_DYNAMIC_MODULES_TRUE@	$(PSD_LIB)	\
+@BUILD_DYNAMIC_MODULES_TRUE@	$(OPENRAW_LIB)	\
 @BUILD_DYNAMIC_MODULES_TRUE@	$(QTIF_LIB)	\
 @BUILD_DYNAMIC_MODULES_TRUE@	$(GDIPLUS_LIBS)
 
@@ -1545,6 +1665,10 @@
 	$(STATIC_ICNS_LIB)	\
 	$(STATIC_PCX_LIB)	\
 	$(STATIC_JASPER_LIB)	\
+	$(STATIC_SVG_LIB)	\
+	$(STATIC_WEBP_LIB)	\
+	$(STATIC_PSD_LIB)	\
+	$(STATIC_OPENRAW_LIB)	\
 	$(STATIC_QTIF_LIB)	\
 	$(STATIC_GDIPLUS_LIBS)
 
@@ -1837,6 +1961,18 @@
 libpixbufloader-jasper.la: $(libpixbufloader_jasper_la_OBJECTS) $(libpixbufloader_jasper_la_DEPENDENCIES) $(EXTRA_libpixbufloader_jasper_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(libpixbufloader_jasper_la_LINK) $(am_libpixbufloader_jasper_la_rpath) $(libpixbufloader_jasper_la_OBJECTS) $(libpixbufloader_jasper_la_LIBADD) $(LIBS)
 
+libpixbufloader-svg.la: $(libpixbufloader_svg_la_OBJECTS) $(libpixbufloader_svg_la_DEPENDENCIES) $(EXTRA_libpixbufloader_svg_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libpixbufloader_svg_la_LINK) $(am_libpixbufloader_svg_la_rpath) $(libpixbufloader_svg_la_OBJECTS) $(libpixbufloader_svg_la_LIBADD) $(LIBS)
+
+libpixbufloader-webp.la: $(libpixbufloader_webp_la_OBJECTS) $(libpixbufloader_webp_la_DEPENDENCIES) $(EXTRA_libpixbufloader_webp_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libpixbufloader_webp_la_LINK) $(am_libpixbufloader_webp_la_rpath) $(libpixbufloader_webp_la_OBJECTS) $(libpixbufloader_webp_la_LIBADD) $(LIBS)
+
+libpixbufloader-psd.la: $(libpixbufloader_psd_la_OBJECTS) $(libpixbufloader_psd_la_DEPENDENCIES) $(EXTRA_libpixbufloader_psd_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libpixbufloader_psd_la_LINK) $(am_libpixbufloader_psd_la_rpath) $(libpixbufloader_psd_la_OBJECTS) $(libpixbufloader_psd_la_LIBADD) $(LIBS)
+
+libpixbufloader-openraw.la: $(libpixbufloader_openraw_la_OBJECTS) $(libpixbufloader_openraw_la_DEPENDENCIES) $(EXTRA_libpixbufloader_openraw_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libpixbufloader_openraw_la_LINK) $(am_libpixbufloader_openraw_la_rpath) $(libpixbufloader_openraw_la_OBJECTS) $(libpixbufloader_openraw_la_LIBADD) $(LIBS)
+
 libpixbufloader-jpeg.la: $(libpixbufloader_jpeg_la_OBJECTS) $(libpixbufloader_jpeg_la_DEPENDENCIES) $(EXTRA_libpixbufloader_jpeg_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(libpixbufloader_jpeg_la_LINK) $(am_libpixbufloader_jpeg_la_rpath) $(libpixbufloader_jpeg_la_OBJECTS) $(libpixbufloader_jpeg_la_LIBADD) $(LIBS)
 
@@ -1909,6 +2045,18 @@
 libstatic-pixbufloader-jasper.la: $(libstatic_pixbufloader_jasper_la_OBJECTS) $(libstatic_pixbufloader_jasper_la_DEPENDENCIES) $(EXTRA_libstatic_pixbufloader_jasper_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(LINK) $(am_libstatic_pixbufloader_jasper_la_rpath) $(libstatic_pixbufloader_jasper_la_OBJECTS) $(libstatic_pixbufloader_jasper_la_LIBADD) $(LIBS)
 
+libstatic-pixbufloader-svg.la: $(libstatic_pixbufloader_svg_la_OBJECTS) $(libstatic_pixbufloader_svg_la_DEPENDENCIES) $(EXTRA_libstatic_pixbufloader_svg_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(LINK) $(am_libstatic_pixbufloader_svg_la_rpath) $(libstatic_pixbufloader_svg_la_OBJECTS) $(libstatic_pixbufloader_svg_la_LIBADD) $(LIBS)
+
+libstatic-pixbufloader-webp.la: $(libstatic_pixbufloader_webp_la_OBJECTS) $(libstatic_pixbufloader_webp_la_DEPENDENCIES) $(EXTRA_libstatic_pixbufloader_webp_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(LINK) $(am_libstatic_pixbufloader_webp_la_rpath) $(libstatic_pixbufloader_webp_la_OBJECTS) $(libstatic_pixbufloader_webp_la_LIBADD) $(LIBS)
+
+libstatic-pixbufloader-psd.la: $(libstatic_pixbufloader_psd_la_OBJECTS) $(libstatic_pixbufloader_psd_la_DEPENDENCIES) $(EXTRA_libstatic_pixbufloader_psd_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(LINK) $(am_libstatic_pixbufloader_psd_la_rpath) $(libstatic_pixbufloader_psd_la_OBJECTS) $(libstatic_pixbufloader_psd_la_LIBADD) $(LIBS)
+
+libstatic-pixbufloader-openraw.la: $(libstatic_pixbufloader_openraw_la_OBJECTS) $(libstatic_pixbufloader_openraw_la_DEPENDENCIES) $(EXTRA_libstatic_pixbufloader_openraw_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(LINK) $(am_libstatic_pixbufloader_openraw_la_rpath) $(libstatic_pixbufloader_openraw_la_OBJECTS) $(libstatic_pixbufloader_openraw_la_LIBADD) $(LIBS)
+
 libstatic-pixbufloader-jpeg.la: $(libstatic_pixbufloader_jpeg_la_OBJECTS) $(libstatic_pixbufloader_jpeg_la_DEPENDENCIES) $(EXTRA_libstatic_pixbufloader_jpeg_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(LINK) $(am_libstatic_pixbufloader_jpeg_la_rpath) $(libstatic_pixbufloader_jpeg_la_OBJECTS) $(libstatic_pixbufloader_jpeg_la_LIBADD) $(LIBS)
 
@@ -2055,6 +2203,10 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-icns.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-ico.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-jasper.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-svg.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-webp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-psd.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-openraw.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-jpeg.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-pcx.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io-pixdata.Plo@am__quote@
--- configure	Tue May 27 07:43:18 2014
+++ configure	Mon Jan 26 14:09:39 2015
@@ -18053,7 +18053,7 @@
 fi
 
 
-if test x$os_win32 = xno || test x$with_gdiplus = xno; then
+#if test x$os_win32 = xno || test x$with_gdiplus = xno; then
   if test x$with_libtiff != xno && test -z "$LIBTIFF"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for TIFFReadRGBAImageOriented in -ltiff" >&5
 $as_echo_n "checking for TIFFReadRGBAImageOriented in -ltiff... " >&6; }
@@ -18212,9 +18212,9 @@
 *** --without-libtiff to configure but some programs using GTK+ may
 *** not work properly" "$LINENO" 5
   fi
-fi
+#fi
 
-if test x$os_win32 = xno || test x$with_gdiplus = xno; then
+#if test x$os_win32 = xno || test x$with_gdiplus = xno; then
   if test x$with_libjpeg != xno && test -z "$LIBJPEG"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for jpeg_destroy_decompress in -ljpeg" >&5
 $as_echo_n "checking for jpeg_destroy_decompress in -ljpeg... " >&6; }
@@ -18339,7 +18339,7 @@
 *** --without-libjpeg to configure but some programs using GTK+ may
 *** not work properly" "$LINENO" 5
   fi
-fi
+#fi
 
   if test x$with_libpng != xno && test -z "$LIBPNG"; then
     for l in libpng16 libpng15 libpng14 libpng12 libpng13 libpng10; do
@@ -18542,13 +18542,13 @@
 # because some important apps like GIMP need to read and write
 # arbitrary tEXt chunks which doesn't seem to be possible through GDI+
 
-all_loaders="ani,icns,pcx,ras,tga,png,pnm,wbmp,xbm,xpm,qtif"
+all_loaders="ani,icns,pcx,ras,tga,png,pnm,wbmp,xbm,xpm,qtif,jpeg,svg,webp,openraw,psd"
 if test x$with_libjasper = xyes; then
   all_loaders="$all_loaders,jasper"
 fi
 if test x$os_win32 = xyes && test x$with_gdiplus != xno; then
   # Skip PNG, see comment above
-  gdip_formats="bmp emf gif ico jpeg tiff wmf"
+  gdip_formats="bmp emf gif ico wmf tiff"
   for f in $gdip_formats; do
     all_loaders="$all_loaders,gdip-$f"
   done
@@ -18724,6 +18724,38 @@
 else
   INCLUDE_JASPER_TRUE='#'
   INCLUDE_JASPER_FALSE=
+fi
+
+ if test x"$INCLUDE_webp" = xyes; then
+  INCLUDE_WEBP_TRUE=
+  INCLUDE_WEBP_FALSE='#'
+else
+  INCLUDE_WEBP_TRUE='#'
+  INCLUDE_WEBP_FALSE=
+fi
+
+ if test x"$INCLUDE_svg" = xyes; then
+  INCLUDE_SVG_TRUE=
+  INCLUDE_SVG_FALSE='#'
+else
+  INCLUDE_SVG_TRUE='#'
+  INCLUDE_SVG_FALSE=
+fi
+
+ if test x"$INCLUDE_psd" = xyes; then
+  INCLUDE_PSD_TRUE=
+  INCLUDE_PSD_FALSE='#'
+else
+  INCLUDE_PSD_TRUE='#'
+  INCLUDE_PSD_FALSE=
+fi
+
+if test x"$INCLUDE_openraw" = xyes; then
+  INCLUDE_OPENRAW_TRUE=
+  INCLUDE_OPENRAW_FALSE='#'
+else
+  INCLUDE_OPENRAW_TRUE='#'
+  INCLUDE_OPENRAW_FALSE=
 fi
 
  if test x"$INCLUDE_qtif" = xyes; then
