Patches for glib 2.42
gapplication.c : revert the use g_win32_get_command_line to glib 2.38 and older, the changes break pygi while native works.
gdbusaddress.c : send the correct path to rundll32
glib-init.c : static build patch (used to works before introduction of gschemas which make it pointless)
gspawn-win32-helper.c : specific patch for gspawner when compiled with mingw but linked to newer msvcrt
gwin32.c : revert to glib 2.40 and older where root path might not having 'bin' folder.

--- gio/gapplication.c	Mon Sep 22 20:42:12 2014
+++ gio/gapplication.c	Thu Sep 25 13:16:29 2014
@@ -2214,23 +2214,16 @@
 {
   gchar **arguments;
   int status;
+  gint i;
 
   g_return_val_if_fail (G_IS_APPLICATION (application), 1);
   g_return_val_if_fail (argc == 0 || argv != NULL, 1);
   g_return_val_if_fail (!application->priv->must_quit_now, 1);
 
-#ifdef G_OS_WIN32
-  arguments = g_win32_get_command_line ();
-#else
-  {
-    gint i;
-
-    arguments = g_new (gchar *, argc + 1);
-    for (i = 0; i < argc; i++)
-      arguments[i] = g_strdup (argv[i]);
-    arguments[i] = NULL;
-  }
-#endif
+  arguments = g_new (gchar *, argc + 1);
+  for (i = 0; i < argc; i++)
+    arguments[i] = g_strdup (argv[i]);
+  arguments[i] = NULL;
 
   if (g_get_prgname () == NULL)
     {
--- gio/gdbusaddress.c	Sat Jul 05 06:59:10 2014
+++ gio/gdbusaddress.c	Wed Sep 24 07:10:58 2014
@@ -1383,7 +1383,13 @@
 	  wchar_t gio_path_short[MAX_PATH];
 	  wchar_t rundll_path[MAX_PATH*2];
 	  wchar_t args[MAX_PATH*4];
-
+    wchar_t root[MAX_PATH];
+    wchar_t root_short[MAX_PATH];
+    wchar_t drive[_MAX_DRIVE];
+    wchar_t dir[_MAX_DIR];
+    _wsplitpath(gio_path, drive, dir, NULL, NULL);
+    _wmakepath(root, drive, dir, NULL, NULL);
+    GetShortPathNameW (root, root_short, MAX_PATH);
 	  GetShortPathNameW (gio_path, gio_path_short, MAX_PATH);
 
 	  GetWindowsDirectoryW (rundll_path, MAX_PATH);
@@ -1403,13 +1409,17 @@
 #elif defined (_MSC_VER)
 	  wcscat (args, L",_g_win32_run_session_bus@16");
 #else
+#if defined(_WIN64) && defined (__MINGW64_VERSION_MAJOR)
+	  wcscat (args, L",g_win32_run_session_bus");
+#else
 	  wcscat (args, L",g_win32_run_session_bus@16");
 #endif
+#endif
 
 	  res = CreateProcessW (rundll_path, args,
 				0, 0, FALSE,
 				NORMAL_PRIORITY_CLASS | CREATE_NO_WINDOW | DETACHED_PROCESS,
-				0, NULL /* TODO: Should be root */,
+				0, root_short /* Changed to glib directory */,
 				&si, &pi);
 	  if (res)
 	    address = read_shm (DBUS_DAEMON_ADDRESS_INFO);
--- glib/glib-init.c	Mon Sep 22 20:42:12 2014
+++ glib/glib-init.c	Thu Sep 25 07:26:18 2014
@@ -237,12 +237,14 @@
 
 #if defined (G_OS_WIN32)
 
+HMODULE glib_dll = NULL;
+
+#ifdef DLL_EXPORT
+
 BOOL WINAPI DllMain (HINSTANCE hinstDLL,
                      DWORD     fdwReason,
                      LPVOID    lpvReserved);
 
-HMODULE glib_dll;
-
 BOOL WINAPI
 DllMain (HINSTANCE hinstDLL,
          DWORD     fdwReason,
@@ -272,7 +274,24 @@
 
   return TRUE;
 }
+#else
+#if defined (G_HAS_CONSTRUCTORS)
+#ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
+#pragma G_DEFINE_CONSTRUCTOR_PRAGMA_ARGS(glib_init_ctor)
+#endif
+G_DEFINE_CONSTRUCTOR(glib_init_ctor)
 
+static void
+glib_init_ctor (void)
+{
+ g_clock_win32_init ();
+#ifdef THREADS_WIN32
+ g_thread_win32_init ();
+#endif
+ glib_init ();
+}
+#endif
+#endif
 #elif defined (G_HAS_CONSTRUCTORS)
 
 #ifdef G_DEFINE_CONSTRUCTOR_NEEDS_PRAGMA
--- glib/gspawn-win32-helper.c	Wed Aug 20 05:11:06 2014
+++ glib/gspawn-win32-helper.c	Tue Sep 23 16:49:45 2014
@@ -33,7 +33,7 @@
  * Please see http://msdn.microsoft.com/zh-tw/library/ks2530z6%28v=vs.80%29.aspx
  * for an explanation on this.
  */
-#if (defined (_MSC_VER) && _MSC_VER >= 1400)
+#if (defined (_MSC_VER) && _MSC_VER >= 1400) || (defined (__MINGW64_VERSION_MAJOR) && __MSVCRT_VERSION__>= 0x0800)
 #include <crtdbg.h>
 #endif
 
@@ -160,7 +160,7 @@
   return argc;
 }
 
-#if (defined (_MSC_VER) && _MSC_VER >= 1400)
+#if (defined (_MSC_VER) && _MSC_VER >= 1400) || (defined (__MINGW64_VERSION_MAJOR) && __MSVCRT_VERSION__>= 0x0800)
 /*
  * This is the (empty) invalid parameter handler
  * that is used for Visual C++ 2005 (and later) builds
@@ -175,7 +175,7 @@
  * Please see http://msdn.microsoft.com/zh-tw/library/ks2530z6%28v=vs.80%29.aspx
  * for an explanation on this.
  */
-void myInvalidParameterHandler(
+static void myInvalidParameterHandler(
    const wchar_t * expression,
    const wchar_t * function,
    const wchar_t * file,
@@ -215,7 +215,7 @@
   _startupinfo si = { 0 };
   char c;
 
-#if (defined (_MSC_VER) && _MSC_VER >= 1400)
+#if (defined (_MSC_VER) && _MSC_VER >= 1400) || (defined (__MINGW64_VERSION_MAJOR) && __MSVCRT_VERSION__>= 0x0800)
   /* set up our empty invalid parameter handler */
   _invalid_parameter_handler oldHandler, newHandler;
   newHandler = myInvalidParameterHandler;
--- glib/gwin32.c	Mon Sep 22 20:42:12 2014
+++ glib/gwin32.c	Thu Sep 25 16:23:10 2014
@@ -238,43 +238,22 @@
 gchar *
 g_win32_get_package_installation_directory_of_module (gpointer hmodule)
 {
-  gchar *filename;
   gchar *retval;
   gchar *p;
   wchar_t wc_fn[MAX_PATH];
 
-  /* NOTE: it relies that GetModuleFileNameW returns only canonical paths */
   if (!GetModuleFileNameW (hmodule, wc_fn, MAX_PATH))
     return NULL;
 
-  filename = g_utf16_to_utf8 (wc_fn, -1, NULL, NULL, NULL);
+  retval = g_utf16_to_utf8 (wc_fn, -1, NULL, NULL, NULL);
 
-  if ((p = strrchr (filename, G_DIR_SEPARATOR)) != NULL)
+  if ((p = strrchr (retval, G_DIR_SEPARATOR)) != NULL)
     *p = '\0';
 
-  retval = g_strdup (filename);
-
-  do
-    {
-      p = strrchr (retval, G_DIR_SEPARATOR);
-      if (p == NULL)
-        break;
-
-      *p = '\0';
-
-      if (g_ascii_strcasecmp (p + 1, "bin") == 0 ||
-          g_ascii_strcasecmp (p + 1, "lib") == 0)
-        break;
-    }
-  while (p != NULL);
-
-  if (p == NULL)
-    {
-      g_free (retval);
-      retval = filename;
-    }
-  else
-    g_free (filename);
+  p = strrchr (retval, G_DIR_SEPARATOR);
+  if (p && (g_ascii_strcasecmp (p + 1, "bin") == 0 ||
+	    g_ascii_strcasecmp (p + 1, "lib") == 0))
+    *p = '\0';
 
 #ifdef G_WITH_CYGWIN
   /* In Cygwin we need to have POSIX paths */
