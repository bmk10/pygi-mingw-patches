--- librsvg.pc.in	Wed Dec 04 03:19:50 2013
+++ librsvg.pc.in	Wed Apr 01 14:18:41 2015
@@ -9,7 +9,7 @@
 Name: librsvg
 Description: library that renders svg files
 Version: @VERSION@
-Requires: glib-2.0 gio-2.0 gdk-pixbuf-2.0 cairo
+Requires: pangocairo libcroco-0.6 glib-2.0 gio-2.0 gdk-pixbuf-2.0
 Requires.private:
 Libs: -L${libdir} -lrsvg-@RSVG_API_MAJOR_VERSION@ -lm
 Cflags: -I${includedir}/librsvg-@RSVG_API_VERSION@
--- rsvg-convert.c	Thu Feb 12 23:31:51 2015
+++ rsvg-convert.c	Sat Aug 15 07:10:26 2015
@@ -43,6 +43,7 @@
 
 #ifdef G_OS_WIN32
 #define WIN32_LEAN_AND_MEAN
+#include <fcntl.h>
 #include <windows.h>
 
 #include <gio/gwin32inputstream.h>
@@ -128,6 +130,7 @@
 
 #ifdef G_OS_WIN32
     HANDLE handle;
+    setmode (fileno (stdout), O_BINARY);
 #endif
 
     GOptionEntry options_table[] = {
@@ -253,12 +256,18 @@
                                                 NULL,
                                                 NULL))) {
                 const char *content_type;
-                char *gz_content_type;
 
                 content_type = g_file_info_get_content_type (file_info);
+#ifdef G_OS_WIN32
+/* Seems win32 don't have svgz mime registry, just verify the extension */
+                if (!stricmp (content_type, ".svgz"))
+                    compressed = TRUE;
+#else
+                char *gz_content_type;
                 gz_content_type = g_content_type_from_mime_type ("application/x-gzip");
                 compressed = (content_type != NULL && g_content_type_is_a (content_type, gz_content_type));
                 g_free (gz_content_type);
+#endif
                 g_object_unref (file_info);
             }
 
--- rsvg-size-callback.c	Wed Dec 04 03:19:50 2013
+++ rsvg-size-callback.c	Tue Mar 31 21:37:49 2015
@@ -94,10 +94,18 @@
     if (real_data->keep_aspect_ratio) {
         int out_min = MIN (*width, *height);
 
+       if (*width == *height) {
+         if (in_height < in_width) {
+             *height = in_height * ((double) *width / (double) in_width);
+         } else {
+             *width = in_width * ((double) *height / (double) in_height);
+         }
+       } else {
         if (out_min == *width) {
             *height = in_height * ((double) *width / (double) in_width);
         } else {
             *width = in_width * ((double) *height / (double) in_height);
         }
     }
+   }
 }
